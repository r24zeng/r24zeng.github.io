---
title: Distributed system - Class 7(Communication)
tags: distributed system
categories: notes
---
> Transfer massages through layers

**Middleware is not total tranparency, so we should understand some implementation.**

RPC libaries allow us to achieve communication bettween layers.

**Transient communication**: when client send massage to server, no middle layer stores the massage.

**Persistent communication**: message is stored in the middle waitting for server to pick up.

**Asynchronous**: client can not be block. When the request is sent, the request is added to a order queue to wait for server recieving. During the time, client can do other things don't need to wait. For example, when you send request to server, browser priorly deal with your previous request, then you will see the web you searched 20 minutes ago, image how suprise you will. But the advantage is that you deal with other tasks during the waiting time.

**Synchronous**: If client sends request, if server is not running, client won't get response any more, and client is blocked until server response. For example, if server is not open and running, your browser will be bocking forever, or the server is running, you can get response immediately.

### client/server
There are lots of ways can be failure between client and server.
+ request arrives to server, process it, then server failed
+ request dosen't arrive server, then failed
+ request is processed, but arriving to client failed
+ request goes back to client, client failed

In conclusion, build middleware is a solution to recognize the failure, so that the client can send request again. Otherwise, the client will block and wait all the time.

### Messaging
**Keep the machenism simple, so easy implement and understanding.**

**RPC**:
- calling and called procedures run on different machines
- parameters & results have to be passed between machines
- one or both machines can crash -> lateer in course

**RPC(remote procesure call)**: client calls funcitons from remote server machines. The power is that the client only needs to call the local side, then the middleware will call the remote server, server then ships massges back. This is a nice and simple mechanism why people like it.

**RPC operation**: client sends "r" reference and first and second parameters, client side needs to mashalling(编组信息)，server will take the responsiblity of shipping the massges to server, server recieve them and unmashlling(解组) and computes massage, then ship them back to client.

How to implement client to server: 
- Question1: If both of them on the local machine, client sent "r" reference to local server, the server can use "r" to access the data. If they are on different machine, client sent "r"(parameter value) reference to remote server, the server can't access the data.
- Question 2: Client send message to remote server, the massge may be reversed, so the server can't recognize the massge. So remote client-server have to have the same architecture.
- Question 3: Have to issue protocals problem (three thiings have to be consider: format, sequence, meaning of massge.)

**RPC parameter passing**: Server recieves messages, unpack messages, read from bottom, client to do this(tell server format, read order and the meaning of the message, array or what?) each of time. Client also needs to know the server's address.
- copy in/copy out semantics: client send copy of values to server, server changes the value, then send back, client sees this is new value, so restores it replace the old value instead of wasiting space. The process doesn't need send reference again. For example, gmail is good, because only some part is changed, don't need to send the whole page again, only pass the changed part. If that is a large object, I only pass my reference of my address instead of sending whole object. But if it's a small object, I can pass it to server.

**RPC in practice**: client and server konws each other's address. If you want to move the server to different machine, the server will fail. Because client doesn't know the new address. Solution is below.

**client-to-server binding(DCE)**:IP and port number, set of API supported to invocation, bind all as interfece in server side. Then client doesn't know how server works inside. Binder inside mechanism as DCE(distributed computation enviroment), if add server, new server register in the direcotory server, send client new IP and port. If one server migrates, register again, send client the new IP and port.

Most **RPC** is implemented by socket. Socket interface includes: socket, bind, listen, accept, connect, send,recieve, close.

Server's socket and bind the port, the server listen to the port and is waiting to get request, until get request then unblock. Client creates socket, send connect code to server, the server has reference to access the message. Actually, the socket is new created by server in order to listen new client. Clinet and server communicate until done then close the port.


Popular socket meaterial: Unix Network parogramming -- steves; Beej's.

### Messgae-oriented middleware
> Email system is successfful.persistent, asynchronous.

send email by address, when hit the "send" is "PUT", you found you are unblocked, you can do other things. But the server must keep up and running, the email goes to queue. Every user has queue number. When you open email client, you read email just implement "GET" read old email from queue based on your ID. "POLL" means ? "NOTIFY" means ?

Some email system is transient. You can use two queues, one queue stores priority, another queue stores regular messages. Queue is easy implement and not easy goes wrong so it is popular.

*Reference material:  <br>
> Reference material: 
> Book: Distributed Systems, Third edition, Version 3.02(2018), Maarten van Steen and Andrew S. Tanenbaum.
> Lectures: University of Waterloo, CS 454/654 (Distributed System), 2020 winter term, Professor Khuzaima Daudjee.